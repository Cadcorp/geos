<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GEOS: geos::coverage::CoverageCleaner Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GEOS<span id="projectnumber">&#160;3.14.0beta3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeos.html">geos</a></li><li class="navelem"><b>coverage</b></li><li class="navelem"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html">CoverageCleaner</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classgeos_1_1coverage_1_1CoverageCleaner-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">geos::coverage::CoverageCleaner Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="CoverageCleaner_8h_source.html">CoverageCleaner.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b9f32c76039eb677481ccfe6c9b9850" id="r_a4b9f32c76039eb677481ccfe6c9b9850"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a4b9f32c76039eb677481ccfe6c9b9850">CoverageCleaner</a> (std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;coverage)</td></tr>
<tr class="separator:a4b9f32c76039eb677481ccfe6c9b9850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af007284c400a3bc61ef8784df4ab5f7c" id="r_af007284c400a3bc61ef8784df4ab5f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#af007284c400a3bc61ef8784df4ab5f7c">setSnappingDistance</a> (double snapDistance)</td></tr>
<tr class="separator:af007284c400a3bc61ef8784df4ab5f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9585ba72afcb393eea6d8f0164473d2b" id="r_a9585ba72afcb393eea6d8f0164473d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a9585ba72afcb393eea6d8f0164473d2b">setOverlapMergeStrategy</a> (int mergeStrategy)</td></tr>
<tr class="separator:a9585ba72afcb393eea6d8f0164473d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1895b1d4b9b8d89747f3369e4fdd2bab" id="r_a1895b1d4b9b8d89747f3369e4fdd2bab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a1895b1d4b9b8d89747f3369e4fdd2bab">setGapMaximumWidth</a> (double maxWidth)</td></tr>
<tr class="separator:a1895b1d4b9b8d89747f3369e4fdd2bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379fddec3cb47c5d663c32a187eff602" id="r_a379fddec3cb47c5d663c32a187eff602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a379fddec3cb47c5d663c32a187eff602">clean</a> ()</td></tr>
<tr class="separator:a379fddec3cb47c5d663c32a187eff602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45b852760627f75beef2a3ee9ac241b" id="r_ae45b852760627f75beef2a3ee9ac241b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#ae45b852760627f75beef2a3ee9ac241b">getResult</a> ()</td></tr>
<tr class="separator:ae45b852760627f75beef2a3ee9ac241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f7a4e32070c802aceba7fbb130ac62" id="r_ab3f7a4e32070c802aceba7fbb130ac62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Polygon.html">Polygon</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#ab3f7a4e32070c802aceba7fbb130ac62">getOverlaps</a> ()</td></tr>
<tr class="separator:ab3f7a4e32070c802aceba7fbb130ac62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ad84cc534faf3891f4c401b84a190f" id="r_a32ad84cc534faf3891f4c401b84a190f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Polygon.html">Polygon</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a32ad84cc534faf3891f4c401b84a190f">getMergedGaps</a> ()</td></tr>
<tr class="separator:a32ad84cc534faf3891f4c401b84a190f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afb7d8ac4fdf572ad6312a698c8272a" id="r_a0afb7d8ac4fdf572ad6312a698c8272a"><td class="memItemLeft" align="right" valign="top"><a id="a0afb7d8ac4fdf572ad6312a698c8272a" name="a0afb7d8ac4fdf572ad6312a698c8272a"></a>
std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>toGeometry</b> (std::vector&lt; <a class="el" href="classgeos_1_1noding_1_1SegmentString.html">SegmentString</a> * &gt; &amp;segStrings, const <a class="el" href="classgeos_1_1geom_1_1GeometryFactory.html">GeometryFactory</a> *geomFact)</td></tr>
<tr class="separator:a0afb7d8ac4fdf572ad6312a698c8272a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca0a172c76a588ec2f6503d87aae779" id="r_aaca0a172c76a588ec2f6503d87aae779"><td class="memItemLeft" align="right" valign="top"><a id="aaca0a172c76a588ec2f6503d87aae779" name="aaca0a172c76a588ec2f6503d87aae779"></a>
std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node</b> (std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;coverage, double snapDistance)</td></tr>
<tr class="separator:aaca0a172c76a588ec2f6503d87aae779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f63d2e2e8e9fbe1b0ecf4e4176dc891" id="r_a8f63d2e2e8e9fbe1b0ecf4e4176dc891"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a8f63d2e2e8e9fbe1b0ecf4e4176dc891">CoverageCleaner</a> (const <a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html">CoverageCleaner</a> &amp;)=delete</td></tr>
<tr class="separator:a8f63d2e2e8e9fbe1b0ecf4e4176dc891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f66a40a93865921833c5aa594e8bf32" id="r_a8f66a40a93865921833c5aa594e8bf32"><td class="memItemLeft" align="right" valign="top"><a id="a8f66a40a93865921833c5aa594e8bf32" name="a8f66a40a93865921833c5aa594e8bf32"></a>
<a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html">CoverageCleaner</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html">CoverageCleaner</a> &amp;)=delete</td></tr>
<tr class="separator:a8f66a40a93865921833c5aa594e8bf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4020e2d926f106291823d7c64daa9c06" id="r_a4020e2d926f106291823d7c64daa9c06"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a4020e2d926f106291823d7c64daa9c06">clean</a> (std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;coverage, double snapDistance, int mergeStrategy, double maxWidth)</td></tr>
<tr class="separator:a4020e2d926f106291823d7c64daa9c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290bf7bb1458b7b5c1daec5e5c32b38b" id="r_a290bf7bb1458b7b5c1daec5e5c32b38b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a290bf7bb1458b7b5c1daec5e5c32b38b">clean</a> (std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;coverage, double snapDistance, double maxWidth)</td></tr>
<tr class="separator:a290bf7bb1458b7b5c1daec5e5c32b38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae17ee2d1feb1e853b2165765c8ffceab" id="r_ae17ee2d1feb1e853b2165765c8ffceab"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#ae17ee2d1feb1e853b2165765c8ffceab">cleanOverlapGap</a> (std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;coverage, int mergeStrategy, double maxWidth)</td></tr>
<tr class="separator:ae17ee2d1feb1e853b2165765c8ffceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c133c843e58565f8ba1bea7fbbc1ba" id="r_ac4c133c843e58565f8ba1bea7fbbc1ba"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#ac4c133c843e58565f8ba1bea7fbbc1ba">cleanGapWidth</a> (std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;coverage, double maxWidth)</td></tr>
<tr class="separator:ac4c133c843e58565f8ba1bea7fbbc1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3b8c70cd2cd27d655159a254d2f19078" id="r_a3b8c70cd2cd27d655159a254d2f19078"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a3b8c70cd2cd27d655159a254d2f19078">MERGE_LONGEST_BORDER</a> = 0</td></tr>
<tr class="separator:a3b8c70cd2cd27d655159a254d2f19078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1765072f1232d32cb222aa328f68258d" id="r_a1765072f1232d32cb222aa328f68258d"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a1765072f1232d32cb222aa328f68258d">MERGE_MAX_AREA</a> = 1</td></tr>
<tr class="separator:a1765072f1232d32cb222aa328f68258d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2555ba4b8a4c0744b96d5b8a27b2f80c" id="r_a2555ba4b8a4c0744b96d5b8a27b2f80c"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a2555ba4b8a4c0744b96d5b8a27b2f80c">MERGE_MIN_AREA</a> = 2</td></tr>
<tr class="separator:a2555ba4b8a4c0744b96d5b8a27b2f80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9f5ca5a6fdb7854b9c9341a12e8468" id="r_a5c9f5ca5a6fdb7854b9c9341a12e8468"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a5c9f5ca5a6fdb7854b9c9341a12e8468">MERGE_MIN_INDEX</a> = 3</td></tr>
<tr class="separator:a5c9f5ca5a6fdb7854b9c9341a12e8468"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cleans the linework of a set of polygonal geometries to form a valid polygonal coverage. The input is an array of valid Polygon or MultiPolygon geometries which may contain topological errors such as overlaps and gaps. Empty or non-polygonal inputs are removed. Linework is snapped together to eliminate small discrepancies. Overlaps are merged with an adjacent polygon, according to a given merge strategy. Gaps narrower than a given width are filled and merged with an adjacent polygon. The output is an array of polygonal geometries forming a valid polygonal coverage.</p>
<p>** Snapping **</p>
<p>Snapping to nearby vertices and line segment snapping is used to improve noding robustness and eliminate small errors in an efficient way, By default this uses a very small snapping distance based on the extent of the input data. The snapping distance may be specified explicitly. This can reduce the number of overlaps and gaps that need to be merged, and reduce the risk of spikes formed by merging gaps. However, a large snapping distance may introduce undesirable data alteration.</p>
<p>** Overlap Merging **</p>
<p>Overlaps are merged with an adjacent polygon chosen according to a specified merge strategy. The supported strategies are:</p>
<ul>
<li><b>Longest Border</b>: (default) merge with the polygon with longest shared border (<a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a3b8c70cd2cd27d655159a254d2f19078">MERGE_LONGEST_BORDER</a>.)</li>
<li><b>Maximum/Minimum Area</b>: merge with the polygon with largest or smallest area (<a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a1765072f1232d32cb222aa328f68258d">MERGE_MAX_AREA</a>, <a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a2555ba4b8a4c0744b96d5b8a27b2f80c">MERGE_MIN_AREA</a>.)</li>
<li><b>Minimum Index</b>: merge with the polygon with the lowest index in the input array (<a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a5c9f5ca5a6fdb7854b9c9341a12e8468">MERGE_MIN_INDEX</a>.)</li>
</ul>
<p>This allows sorting the input according to some criteria to provide a priority for merging gaps.</p>
<p>** Gap Merging **</p>
<p>Gaps which are wider than a given distance are merged with an adjacent polygon. Polygon width is determined as twice the radius of the MaximumInscribedCircle of the gap polygon. Gaps are merged with the adjacent polygon with longest shared border. Empty holes in input polygons are treated as gaps, and may be filled in. Gaps which are not fully enclosed ("inlets") are not removed.</p>
<p>Cleaning can be run on a valid coverage to remove gaps.</p>
<p>The clean result is an array of polygonal geometries which match one-to-one with the input array. A result item may be <code>null</code> if:</p>
<ul>
<li>the input item is non-polygonal or empty</li>
<li>the input item is so small it is snapped to collapse</li>
<li>the input item is covered by another input item (which may be a larger or a duplicate (nearly or exactly) geometry)</li>
</ul>
<p>The result is a valid coverage according to <a class="el" href="classgeos_1_1coverage_1_1CoverageValidator.html#ae83e88118dc5b5be037449f5ed36de50">CoverageValidator::isValid()</a>;</p>
<p>** Known Issues **</p>
<ul>
<li>Long narrow gaps adjacent to multiple polygons may form spikes when merged with a single polygon.</li>
</ul>
<p>** Future Enhancements **</p>
<ul>
<li>Provide an area-based tolerance for gap merging</li>
<li>Prevent long narrow gaps from forming spikes by partitioning them before merging.</li>
<li>Allow merging narrow parts of a gap while leaving wider portions.</li>
<li>Support a priority value for each input polygon to control overlap and gap merging (this could also allow blocking polygons from being merge targets)</li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgeos_1_1coverage_1_1CoverageValidator.html">CoverageValidator</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Martin Davis </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b9f32c76039eb677481ccfe6c9b9850" name="a4b9f32c76039eb677481ccfe6c9b9850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9f32c76039eb677481ccfe6c9b9850">&#9670;&#160;</a></span>CoverageCleaner() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geos::coverage::CoverageCleaner::CoverageCleaner </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coverage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new cleaner instance for a set of polygonal geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coverage</td><td>an array of polygonal geometries to clean </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f63d2e2e8e9fbe1b0ecf4e4176dc891" name="a8f63d2e2e8e9fbe1b0ecf4e4176dc891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f63d2e2e8e9fbe1b0ecf4e4176dc891">&#9670;&#160;</a></span>CoverageCleaner() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geos::coverage::CoverageCleaner::CoverageCleaner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html">CoverageCleaner</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable copy construction and assignment. Apparently needed to make this class compile under MSVC. (See <a href="https://stackoverflow.com/q/29565299">https://stackoverflow.com/q/29565299</a>) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a379fddec3cb47c5d663c32a187eff602" name="a379fddec3cb47c5d663c32a187eff602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379fddec3cb47c5d663c32a187eff602">&#9670;&#160;</a></span>clean() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geos::coverage::CoverageCleaner::clean </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans the coverage. </p>

</div>
</div>
<a id="a290bf7bb1458b7b5c1daec5e5c32b38b" name="a290bf7bb1458b7b5c1daec5e5c32b38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290bf7bb1458b7b5c1daec5e5c32b38b">&#9670;&#160;</a></span>clean() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt; geos::coverage::CoverageCleaner::clean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>snapDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans a set of polygonal geometries to form a valid coverage, using the default overlap merge strategy <code><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a3b8c70cd2cd27d655159a254d2f19078">MERGE_LONGEST_BORDER</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coverage</td><td>an array of polygonal geometries to clean </td></tr>
    <tr><td class="paramname">snapDistance</td><td>the distance tolerance for snapping </td></tr>
    <tr><td class="paramname">maxWidth</td><td>the maximum width of gaps to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the clean coverage </dd></dl>

</div>
</div>
<a id="a4020e2d926f106291823d7c64daa9c06" name="a4020e2d926f106291823d7c64daa9c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4020e2d926f106291823d7c64daa9c06">&#9670;&#160;</a></span>clean() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt; geos::coverage::CoverageCleaner::clean </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>snapDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mergeStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans a set of polygonal geometries to form a valid coverage, allowing all cleaning parameters to be specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coverage</td><td>an array of polygonal geometries to clean </td></tr>
    <tr><td class="paramname">snapDistance</td><td>the distance tolerance for snapping </td></tr>
    <tr><td class="paramname">mergeStrategy</td><td>the strategy to use for merging overlaps </td></tr>
    <tr><td class="paramname">maxWidth</td><td>the maximum width of gaps to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the clean coverage </dd></dl>

</div>
</div>
<a id="ac4c133c843e58565f8ba1bea7fbbc1ba" name="ac4c133c843e58565f8ba1bea7fbbc1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c133c843e58565f8ba1bea7fbbc1ba">&#9670;&#160;</a></span>cleanGapWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt; geos::coverage::CoverageCleaner::cleanGapWidth </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans a set of polygonal geometries to form a valid coverage, with default snapping tolerance and overlap merging, and merging gaps which are narrower than a specified width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coverage</td><td>an array of polygonal geometries to clean </td></tr>
    <tr><td class="paramname">maxWidth</td><td>the maximum width of gaps to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the clean coverage </dd></dl>

</div>
</div>
<a id="ae17ee2d1feb1e853b2165765c8ffceab" name="ae17ee2d1feb1e853b2165765c8ffceab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae17ee2d1feb1e853b2165765c8ffceab">&#9670;&#160;</a></span>cleanOverlapGap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt; geos::coverage::CoverageCleaner::cleanOverlapGap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mergeStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxWidth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cleans a set of polygonal geometries to form a valid coverage, using the default snapping distance tolerance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coverage</td><td>an array of polygonal geometries to clean </td></tr>
    <tr><td class="paramname">mergeStrategy</td><td>the strategy to use for merging overlaps </td></tr>
    <tr><td class="paramname">maxWidth</td><td>the maximum width of gaps to merge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the clean coverage </dd></dl>

</div>
</div>
<a id="a32ad84cc534faf3891f4c401b84a190f" name="a32ad84cc534faf3891f4c401b84a190f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ad84cc534faf3891f4c401b84a190f">&#9670;&#160;</a></span>getMergedGaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Polygon.html">Polygon</a> * &gt; geos::coverage::CoverageCleaner::getMergedGaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets polygons representing the gaps in the input which have been merged.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of gap polygons </dd></dl>

</div>
</div>
<a id="ab3f7a4e32070c802aceba7fbb130ac62" name="ab3f7a4e32070c802aceba7fbb130ac62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f7a4e32070c802aceba7fbb130ac62">&#9670;&#160;</a></span>getOverlaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="classgeos_1_1geom_1_1Polygon.html">Polygon</a> * &gt; geos::coverage::CoverageCleaner::getOverlaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets polygons representing the overlaps in the input, which have been merged.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of overlap polygons </dd></dl>

</div>
</div>
<a id="ae45b852760627f75beef2a3ee9ac241b" name="ae45b852760627f75beef2a3ee9ac241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45b852760627f75beef2a3ee9ac241b">&#9670;&#160;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classgeos_1_1geom_1_1Geometry.html">Geometry</a> &gt; &gt; geos::coverage::CoverageCleaner::getResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the cleaned coverage.</p>
<dl class="section return"><dt>Returns</dt><dd>the clean coverage </dd></dl>

</div>
</div>
<a id="a1895b1d4b9b8d89747f3369e4fdd2bab" name="a1895b1d4b9b8d89747f3369e4fdd2bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1895b1d4b9b8d89747f3369e4fdd2bab">&#9670;&#160;</a></span>setGapMaximumWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geos::coverage::CoverageCleaner::setGapMaximumWidth </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxWidth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum width of the gaps that will be filled and merged. The width of a gap is twice the radius of the Maximum Inscribed Circle in the gap polygon, A width of zero prevents gaps from being merged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxWidth</td><td>the maximum gap width to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9585ba72afcb393eea6d8f0164473d2b" name="a9585ba72afcb393eea6d8f0164473d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9585ba72afcb393eea6d8f0164473d2b">&#9670;&#160;</a></span>setOverlapMergeStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geos::coverage::CoverageCleaner::setOverlapMergeStrategy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mergeStrategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the overlap merge strategy to use. The default is <code><a class="el" href="classgeos_1_1coverage_1_1CoverageCleaner.html#a3b8c70cd2cd27d655159a254d2f19078">MERGE_LONGEST_BORDER</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mergeStrategy</td><td>the merge strategy code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af007284c400a3bc61ef8784df4ab5f7c" name="af007284c400a3bc61ef8784df4ab5f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af007284c400a3bc61ef8784df4ab5f7c">&#9670;&#160;</a></span>setSnappingDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geos::coverage::CoverageCleaner::setSnappingDistance </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>snapDistance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the snapping distance tolerance. The default is to use a small fraction of the input extent diameter. A distance of zero prevents snapping from being used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snapDistance</td><td>the snapping distance tolerance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3b8c70cd2cd27d655159a254d2f19078" name="a3b8c70cd2cd27d655159a254d2f19078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8c70cd2cd27d655159a254d2f19078">&#9670;&#160;</a></span>MERGE_LONGEST_BORDER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int geos::coverage::CoverageCleaner::MERGE_LONGEST_BORDER = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge strategy that chooses polygon with longest common border </p>

</div>
</div>
<a id="a1765072f1232d32cb222aa328f68258d" name="a1765072f1232d32cb222aa328f68258d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1765072f1232d32cb222aa328f68258d">&#9670;&#160;</a></span>MERGE_MAX_AREA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int geos::coverage::CoverageCleaner::MERGE_MAX_AREA = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge strategy that chooses polygon with maximum area </p>

</div>
</div>
<a id="a2555ba4b8a4c0744b96d5b8a27b2f80c" name="a2555ba4b8a4c0744b96d5b8a27b2f80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2555ba4b8a4c0744b96d5b8a27b2f80c">&#9670;&#160;</a></span>MERGE_MIN_AREA</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int geos::coverage::CoverageCleaner::MERGE_MIN_AREA = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge strategy that chooses polygon with minimum area </p>

</div>
</div>
<a id="a5c9f5ca5a6fdb7854b9c9341a12e8468" name="a5c9f5ca5a6fdb7854b9c9341a12e8468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9f5ca5a6fdb7854b9c9341a12e8468">&#9670;&#160;</a></span>MERGE_MIN_INDEX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int geos::coverage::CoverageCleaner::MERGE_MIN_INDEX = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge strategy that chooses polygon with smallest input index </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="CoverageCleaner_8h_source.html">CoverageCleaner.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
